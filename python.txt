.//notes.txt:21:Converts Python tests to C.
.//Makefile:106:	-rm -f $(TESTSDIR)/Python/Logs/*.txt $(TESTSDIR)$(SP)
.//Tests/Python/README.md:1:# Python tests
.//Tests/Python/README.md:2:Since the difficulty of testing in C a project divided into client and server, most of the tests were done by simulating clients processes with Python. This is done in the "./pythontests.py" file. The tests are written in Python 3 and should work with all libraries installed by default without requiring any external resources. 
.//Tests/Python/pythontests.py:55:print("So the command used should be something like: 'python3 ./Tests/Python/pythontests.py localhost 8080'.")
.//Tests/Python/pythontests.py:61:    filestdoutlogs = open(f"./Tests/Python/Logs/stdout-log-{i}.txt", "w") # Creating the stdout logs file.
.//Tests/Python/pythontests.py:64:    filestdinlogs = open(f"./Tests/Python/Logs/stdin-log-{i}.txt", "w") # Creating the stdin logs file.
.//Tests/Python/pythontests.py:90:            filestdinlogs = open(f"./Tests/Python/Logs/stdin-log-{i}.txt", "a") # Appending the stdin logs file.
.//Tests/README.md:7:## Python subfolder
.//Tests/README.md:8:In the "./Python" subfolder you will find some extensive project's tests written in Python 3.
.//Docs/Report/compilazione.tex:12:\item make clean = Rimuove tutti i files oggetto, eseguibili, files di logs dei tests Python e termina forzatamente tutti gli eventuali processi in esecuzione di server e client.
.//Docs/Report/compilazione.tex:24:\textbf{ATTENZIONE:} L'utilizzo di alcuni percorsi assoluti hard-coded (ad esempio il percorso del file dizionario di default quando non specificato da CLI) assume che la \textbf{WORKING DIRECTORY} sia la \textbf{ROOT} del progetto. Stessa cosa per lo script "./Tests/Python/pythontests.py".
.//Docs/Report/strutturatests.tex:3:Inizialmente l'idea era di scrivere i tests in C in un file eseguibile separato. Ho intrapreso questa strada, testimone il fatto che nella cartella "./Tests/C/" ho lasciato il file "tests.c", il quale funziona, si pu\'o compilare ed eseguire. Tuttavia, con lo sviluppo mi sono reso conto che per come ho strutturato il progetto era disastroso. Avrei potuto testare poche singole funzioni ma non ad un livello soddisfacente nell'insieme. Causa il fatto di avere i codici divisi in pi\'u file ed di aver utilizzato per molte funzionalit\'a variabili globali condivise. Allora, ho guardato qualche framework di testing in C, ma non ho trovato nulla che facesse al caso mio. Cos\'i, messo alle strette, ho pensato di approcciare il problema in modo "particolare". Mi \'e venuto in mente che avrei potuto utilizzare la semplicit\'a e la potenza di Python, che conosco un poco, per fare i tests in modo esterno, ma simulando proprio il comportamento di utenti ed interazioni con il server anche su larga scala. Ha funzionato benissimo! Solamente \textbf{mi dispiace di esser dovuto andare a scomodare un linguaggio che esula dal corso}. Tuttavia, credo sia stato didatticamente utile perch\'e, seppur in un linguaggio diverso, ho dovuto maneggiare files, PIPES e segnali. In questo modo ho potuto eseguire moltissimi tests che sono stati vitali e mi hanno permesso di correggere innumerevoli bugs che con pochi clients (tstati manualmente) non si verificano, soprattutto sviste con la memoria. Per eseguire questi tests \'e sufficiente:
.//Docs/Report/strutturatests.tex:7:  \item Dalla root del progetto eseguire "python3 ./Tests/Python/pythontests.py server\_ip porta\_server". 
.//Docs/Report/strutturatests.tex:10:Ci sono alcuni parametri all'inizio del file che possono essere modificati se voluto. Il file crea tantissimi processi client e per ognuno di essi svolge un numero di azioni che possono essere esattamente tutte quelle che un vero utente potrebbe eseguire. Inviare comandi non validi, registrarsi, richiedere la matrice, sottomettere una parola, di quelle valide e non valide, uscire e persino disconnettersi forzatamente. Tutto viene svolto casualmente con un intensivo uso di random (ma comunque replicabile tramite seed). Tra ogni azione si aspetta un numero casuale di millisecondi per aumentare l'entropia. I comandi vengono sottomessi da Python, creando il processo del client  collegandosi tramite PIPE al suo STDIN. L'input inviato (comandi) e l'output ricevuto, ossia le risposte che il client ha ricevuto dal server, vengono salvati in dei file di logs in "./Tests/Python/Logs/".
.//Docs/Report/strutturatests.tex:12:I tests dovrebbero funzionare con una recente (al 2024) versione di Python 3, con le librerie installate di default, senza richiedere alcuna risorsa esterna.
.//TODO.md:11:- [ ] Re-insert command "end" in Python tests.
.//TODO.md:26:- [x] Check Tests/Python/pythontests.py.
Binary file .//.git/index matches
.//Src/Server/server.c:41:#define VALID_WORDS_TESTS_FILE_PATH "./Tests/fileCurrentValidsWords.txt" // This is the path to a special file that will be used to perform some tests. It will contain ALL the words present in the current game matrix and in the dictionary. For more info see "../../Tests/Python/pythontests.py".
