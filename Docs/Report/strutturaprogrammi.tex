\chapter{Struttura programmi}

\section{Server e client in comune}

\subsection{Funzioni comuni}

Il server ed il client condividono librerie utilizzate e molto codice per delle funzionalit\'a richieste comuni grazie ai files common.h e common.c. 
\\
Enunciamo sinteticamente le funzioni condivise. Abbiamo una funzione per fare il parsing dell'IP ottenuto dalla riga di comando, una per trasformare le stringhe in UPPERCASE o lowercase, le fondamentali receiveMessage() e sendMessage() che servono a scambiarsi i messaggi tra server e client, una funzione destroyMessage() per deallocare tali messaggi, due wrapper mLock() e mULock(), rispettivamente delle funzioni pthread\_mutex\_lock() e pthread\_mutex\_unlock(), utilizzati per controllare gli errori, una funzione handleError() dedicata alla gestione degli errori, una funzione wrapper printff() di quella della libreria, printf(), per stampare messaggi su stdout ed errori su stderr, che insieme ad un mutexprint permette la stampa di stringhe multiple senza che ne vengano interposte altre da altri thread quando necessario, una funzione createBanner() che crea delle stringhe carine da stampare per suddividere l'output e facilitarne la lettura ed infine una funzione threadSetup() che si occupa di associare un distruttore ad ogni thread, richiamato alla sua terminazione. Tali funzioni sono identiche in server e client.
 
 \subsection{Funzioni comuni ma con differente implementazione}

 I thread condividono il possedere un thread dedicato alla gestione dei segnali ricevuti. L'implementazione del thread differisce leggermente tra i due, poich\'e il server aveva la necessit\'a di gestire il SIGALRM in modo impegnativo (perch\'e usato per terminare il gioco), che il client non doveva. I server ed il client hanno due versioni differenti della funzione threadDestructor() che come predetto viene chiamata alla terminazione di qualunque thread, ed in base al chiamante esegue dei cleaner differenti. Per concludere vi \'e una funzione atExit() che viene chiamata al termine del programma dal thread main che si occupa anch'essa di fare pulizia.
 
\section{Gestione segnali}

Come anticipato, vi \'e un thread dedicato alla gestione dei segnali. Questo intercetta i segnali ricevuti da gestire, attraverso un loop, con una sigwait(). Inizialmente lo sviluppo \'e stato fatto con la registrazione dei signals handlers, ma questo esponeva ad innumerevoli difficolt\'a dovute al fatto che il segnale pu\'o finire ad un thread casuale e sopratutto che nel suo gestore, si \'e costretti ad utilizzare un numero estremamente ridotto di funzioni che devono avere la caratteristica di essere async-signal-safe. Con l'uso di un thread dedicato e della sigwait() invece sappiamo gi\'a il thread che ricever\'a il segnale e possiamo gestirlo liberamente.

\section{Server}

\subsection{Thread main}

Il server, dopo un'iniziale fase di setup, con inizializzazioni di varie strutture dati, registrazione del thread distruttore e della funzione atExit(), controllo degli argomenti ricevuti da riga di comando, avvio e configurazione del thread per la gestione dei segnali, registrazione del gestore dell'unico segnale (SIGUSR1) non gestito dal predetto thread, caricamento del file dizionario e matrici (se presente), apre un socket, si mette in ascolto, avvia il primo gioco (impostando un timer di fine partita con la chiamata alarm()) e si mette ad accettare clients indefinitivamente in un ciclo. All'arrivo di un client (connessione), lo accetta, inizializza un nuovo elemento della lista clients, aggiungendolo a tale lista (con dovute sincronizzazioni) ed infine avvia un thread (clientHandler()) dedicato alla gestione del giocatore, passandogli come argomento il puntatore alla propria struttura dati aggiunta alla lista.

 \subsection{Thread clientHandler()}

 Il neoavviato thread si mette in un loop ad attendere la ricezione di un messaggio dal client attraverso la funzione receiveMessage() che al suo interno utilizza la chiamata read() per leggere le varie componenti del messaggio dal socket utente. All'arrivo di un messaggio COMPLETO tenta di acquisire il proprio mutex. Ogni client, infatti, all'interno della propria struttura dati, ha anche un suo personale mutex, che acquisisce durante l'elaborazione di un messaggio ricevuto, per poi rilasciarlo al termine. Tale mutex \'e posto DOPO la lettura del messaggio, ma PRIMA della sua elaborazione.
 
 \subsection{Thread signalsThread()}

Quando il tempo di gioco termina, si riceve un segnale SIGALRM che verr\'a intercettato dal thread gestore segnali ed inizier\'a la fase pi\'u complessa del progetto. Sincronizzandosi opportunamente bloccher\'a tutti i threads clientHandler() acquisendo ciascun loro mutex. Se non dovesse riuscire ad acquisirne uno, ritenter\'a. In questo modo si \'e scelto di dare la priorit\'a al thread clientHandler() che sta gestendo un messaggio, questo ci garantisce la piacevole propriet\'a che tutte le richieste ricevute PRIMA dello scadere del timer siano processate come \'e giusto che sia. A seguire, il thread signalsThread() abilita la pausa, modificando una variabile globale (pauseon), che in seguito istruir\'a i clientHandler() threads di rispondere alle richieste di conseguenza (siamo in pausa). Ad ognuno di questi threads da parte del signalsHandler() che sta gestendo il SIGALRM verr\'a inviato il segnale SIGUSR1 per il quale nel main era stato registrato un handler (questo segnale NON \'e gestito dal signalThread(), ma ogni clientHandler() thread lo ricever\'a e gestir\'a). Lo scopo di questa azione \'e interrompere eventuali read() sulle quali il clientHandler() si dovesse trovare, perch\'e adesso (dopo esser stati sbloccati dal signalsHandler() con il rilascio del proprio mutex) i clientHandler() threads dovranno riempire la coda con i messaggi contenenti il punteggio del giocatore con le dovute sincronizzazioni (usando il queuemutex). Quando la coda sar\'a stata riempita, il signalsThread() thread avvier\'a il thread scorer() che stiler\'a la classifica finale recuperando i messaggi dalla coda ed ordinandoli per punteggio discendente con una chiamata qsort(). Al termine del scorer() thread, il signalsThread() che lo avr\'a aspettato con una join, ribloccher\'a tutti i clientHandler() threads (sempre acquisendo ciascun loro mutex scorrendo la lista), li comunicher\'a che la scoreboard CSV \'e pronta e loro (i clientHandler()) dopo esser stati tutti liberati, invieranno la scoreboard ai propri (corrispettivi) utenti. A questo punto signalsThread() non dovr\'a far altro che avviare il thread gamePause() che eseguir\'a la sleep di durata della pausa, signalsThread() far\'a il join su questo thread. Nel frattempo ovviamente tutti i clientHandler() saranno liberi di operare rispondendo liberamente alle richieste dei giocatori (tenendo conto che la pausa \'e stata abilitata). Al termine di gamePause() thread, signalsThread() bloccher\' nuovamente tutti i clientHandler() threads, disabiliter\'a la pausa, imposter\'a una nuova matrice (dal file o causale), aggiorner\'a il words\_validated array cercando tutte le parole del dizionario nella nuova matrice, imposter\'a di conseguenza il words\_validated di ciascun giocatore ed infine avvier\'a un nuovo gioco (nuova chiamata ad alarm()) e si metter\'a in attesa di nuovi segnali, cos\'i il ciclo potr\'a ricominciare.

\section{Client}

Lo sviluppo del client \'e stato sorprendentemente pi\'u arduo di quello del server, nonostante la sua abbastanza oggettiva semplicit\'a. Il concetto chiave su cui mi sono concentrato \'e stato la pulizia della stampa delle risposte del server e la successiva stampa (e gestione degli input) del prompt. Pu\'o sembrare superficiale, ma senza la giusta attenzione, l'interfaccia grafica risultava disastrosa. Pu\'0 sembrare un dettaglio, ma \'e stato difficile far fronte a questa questa esigenza,  sulla quale mi sono incaponito nel non voler scendere a compromessi. Nello specifico, il problema e\' che quando viene ricevuta e stampata una risposta dal server, l'utente potrebbe essere nel mezzo di una digitazione e aver gi\'a inserito dei caratteri nel buffer STDIN. Per vedere il problema si pu\'o guardare il codice nel file brokeninputoutput.c, nella cartella Studies/. Ho individuato due modi per affrontare il problema:
\\
- Prevenirlo. Sviluppando il client come un singolo thread, che attende che l'utente completi l'input (premendo ENTER, che tramite '\textbackslash n' interrompe la read()), poi esegue l'input ed infine controlla se ci sono risposte del server da stampare e ricomincia il ciclo. Oppure, sviluppare il client come multithread e sincronizzare il thread che gestisce l'input con quello che stampa le risposte del server. Entrambe le soluzioni, hanno lo stesso difetto: la read() deve essere obbligatoriamente bloccante, per essere sicuri di leggere l'intero buffer STDIN.
\\
- Risolverlo, lasciando che il buffer STDIN possa "sporcarsi" e pulirlo quando necessario. Sembra semplice, ma non lo \'e, ho trovato solo metodi non funzionanti su internet.
\\
Ho finito per tentare con una nota libreria chiamata ncurses. Questa permette di gestire il terminale nel dettaglio, ma era inappropiata. Risolveva il problema, ma generava una complessit\'a insostenibile per le semplici stampe che dovevo fare. 
\\
Dopo innumerevoli tentativi sono riuscito a risolvere il problema in modo semplice, ricorrendo a due librerie ma senza doverne fare un uso estensivo. Ho utilizzato termios, vedere termiostest.h nella cartella Studies/ e fcntl. Utilizzo due threads, uno per la gestione dell'input utente e della stampa delle risposte del server (quest'ultime vengono lette da una lista) ed uno che legge le risposte del server dal socket e le inserisce in lista. Interrompo la read() nel primo thread molto spesso e controllo se ci sono risposte del server, in caso affermativo, le stampo, ripulisco lo STDIN con una getchar() NON BLOCCANTE e ritorno al prompt pulito, in modo che se l'utente avesse digitato qualcosa di incompleto possa riscriverlo e/o modificarlo (a seguito della risposta). Invece, se non ci sono risposte dal server, la read() riprende con lo STDIN inserito dall'utente che non si accorge di nulla. L'unico svantaggio \'e che le stampe delle risposte del server non avvengono in modo asincrono, si ottiene un effetto simile per l'utente, perch\'e la read() viene interrotta ogni pochi millisecondi per stampare le risposte del server. La ricezione delle risposte e l'inserimento in lista invece e\' eseguita da un thread ad-hoc e quindi e\' totalmente asincrono, ma la stampa no. La sincronizzazione tra i due threads avviene con un mutex. Le due librerie citate servono solo a rendere la getchar() non bloccante e permettermi quindi di pulire l'STDIN. Per approfondire vedasi inputoutputasynctests.c nella cartella Studies/.
\\
Un ulteriore problema affrontato \'e stato quello di non sapere anticipatamente la grandezza dell'input dell'utente. Non vi sono infatti limitazioni sulla lunghezza della parola o del nome utente, per poter gestire input di arbitraria dimensione si leggono BUFFER\_SIZE caratteri dallo STDIN con una read(), essi vengono inseriti in un char array[BUFFER\_SIZE] statico, ma da qui vengono poi copiati in una stringa allocata sullo heap dinamicamente (sempre di lunghezza BUFFER\_SIZE) che viene aggiunta ad una lista concatenata di stringhe. Scegliendo cos\'i un BUFFER\_SIZE adeguato allocheremo sempre la dimensione di memoria che pi\'u si avvicina alla grandezza dell'input dell'utente evitando di preallocare tanta memoria inutilmente che poi comunque se allocata staticamente potrebbe terminare (in caso di input utente grandi), con una lista di stringhe si ovvia a questo problema.


