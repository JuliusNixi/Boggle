\chapter{Miscellanea}

Le funzionalit\'a di cui sono pi\'u orgoglioso sono:
\begin{itemize}
\item Il server pu\'o far giocare potenzialmente infiniti giocatori.
\item La matrice di gioco pu\'o essere N x N di dimensione arbitraria.
\item Le parole del gioco possono avere lunghezza arbitraria.
\item L'input dell'utente nel client pu\'o essere di lunghezza arbitraria (parole sottomesse e lunghezza nickname di registrazione).
\item Le stampe nel client sono ben strutturate, la GUI non mostra mai stampe incoerenti.
\item I tests eseguiti mostrano una buona resa e stabilit\'a di server e clients.
\item Il client \'e semplice poich\'e il grosso del lavoro lo esegue il server.
\end{itemize}
\leavevmode 
Tutta la sincronizzazione \'e stata volutamente fatta solamente tramite mutex, dove talvolta le variabili di condizione o i semafori si sarebbero potuti utilizzare, per cercare di rendere il codice pi\'u semplice ed intuitivo possibile, seppur abbia ancora le sue complessit\'a.
 \\
 Le parole, indipendentemente da come arrivino dal client e da come siano scritte nei file dizionario vengono convertite in UPPERCASE dal server. Anche i caratteri componenti la matrice di gioco sono gestiti esclusivamente in UPPERCASE, sia nella generazione casuale, sia nella lettura da file (se scritte in lowercase in quest'ultimo vengono convertite in UPPERCASE). Gli unici caratteri ammessi per le parole, le matrici e i nicknames degli utenti sono: "abcdefghijklmnopqrstuvwxyz", contenuto nella definizione "ALPHABET" in "server.h". L'input del client, invece, viene tutto convertito a lowercase prima di essere elaborato ed inviato, quindi il comando inserito "MaTrIcE" sar\'a valido come "matrice".
 \\
 A tutte le informazioni che possono essere espresse solamente con numeri interi positivi \'e stato assegnato il tipo "unsigned long int" abbreviato con il "typedef" ad "uli". Per le variabili booleane (o a carattere discreto) \'e stato utilizzato il tipo "char" poich\'e occupa solo un byte.
 \\
 Perch\'e nel server le "read()" nella funzione "receiveMessage()", chiamata dai "clientHandler()" threads, viene interrotta tramite l'invio (da parte del "signalsThread()" thread) del segnale SIGUSR1, mentre nel client la "read()" dello STDIN viene interrotta autonomamente grazie alla libreria "fcntl"? Semplicemente perch\'e non sapevo si potesse fare con questa libreria quando ho sviluppato il server, che ho sviluppato per prima, quando successivamente, sviluppando il client l'ho scoperto, sono rimasto deluso da tutta l'inutile complessit\'a che ho dovuto gestire nel server, ma questo funziona ugualmente e mostra pi\'u attinenza agli argomenti trattati nel corso, quindi l'ho felicemente lasciato cos\'i.
 \\
 Durante lo sviluppo del client, per tentare di risolvere il problema spiegato sulla sincronizzazione input/output e buffer STDIN, sono finito per sperimentare con una nota libreria chiamata "ncurses". Questa permette di gestire il terminale nel dettaglio, ma era inapropiata al mio use case. Risolveva il problema, ma generava una complessit\'a in tutto il resto insostenibile per le semplici stampe che dovevo fare. Questo mi ha insegnato che anche fare delle "presumibilmente semplici" interfacce grafiche testuali non \'e sempre cos\'i scontato come credessi.
 \\
All'interno di "./Studies/C/SchedPolicyPriorityPThreads/" ci sono dei tests realizzati per un problema serio che ha avuto il progetto. Nel testarlo, \'e emerso che, all'aumentare del numero di giocatori/clienti connessi, il server diventava sempre pi\'u lento nel gestire le fasi di gioco/pausa, nell'accettare nuove connessioni socket e nel rispondere alle richieste dei giocatori, finch\'e il gioco diventava ingiocabile e il server si fermava per tanto tempo (senza mai stallare per\'o). Mi sono reso conto che, con l'aumentare del numero di threads, era sempre pi\'u probabile che venisse schedulato un thread "clientHandler()" (gestore di un giocatore) piuttosto che i thread main (mian "acceptClient()" che accetta le nuove connessioni) e "signalsThread()" (gestore delle fasi di gioco) (ed anche i suoi threads di supporto "scorer()" e "gamePauseAndNewGame()"), che sono quelli critici per il corretto funzionamento dell'intero progetto. Per il modo in cui \'e strutturato il progetto, questo era un aspetto critico. Infatti, i threads "clientHandler()", per garantire una risposta ottimale ai clients, non si sospendono mai, ma semplicemente si bloccano sui mutexes. Lo stesso thread "signalsThread()" cerca di acquisire i mutexes utilizzati dai threads "clientHandler()". Il risultato, esemplificando con un esempio, \'e che, se abbiamo un mutex M, 100 threads "clientHandler()" C, e 1 thread "signalsThread()" S (lo stesso ragionamento si applica al singolo thread main ("acceptClient()")) che cercano tutti di acquisire M, \'e molto pi\'u probabile che venga schedulato un thread C, che acquisisca M, faccia qualcosa, lo rilasci e vada in loop, ora arriva un segnale di fine gioco, il thread S interviene per gestirlo, ma si blocca su M, dato che ci sono 100 thread C, \'e molto probabile che siano schedulati una, pi\'u volte o potenzialmente infinite, e il thread S attende sul mutex M indefinitivamente, non c'\'e nessun DEADLOCK, ma il server si ferma per molto tempo prima di accettare nuove connessioni o di terminare il gioco, proprio perch\'e deve "sperare" che il thread "giusto" sia S, quello che acquisisce M. Un'intera ristrutturazione del progetto avrebbe risolto il problema, ma non volendo perdere il tempo investito, ho cercato di non demoralizzarmi e cercare una soluzione. La prima idea che ho avuto \'e stata quella di provare ad aumentare la priorit\'a di schedulazione dei threads "acceptClient()" e "signalsThread()". Nei files di questa cartella vedrete questo tentativo che, sebbene riuscito, non ha risolto il problema, perch\'e anche impostando la priorit\'a dei thread "clientHander()" al minimo possibile, questi hanno continuato ad acquisire i mutexes a spese dei threads s"ignalsThread()" e "acceptClient()". Alla fine ho notato che la soluzione potesse essere molto pi\'u semplice e indolore, \'e bastato aggiungere un mutex di "alta priorit\'a" aggiuntivo e questa soluzione si trova nel file "./Studies/C/SchedPolicyPriorityPThreads/prioritypthreadssolution.c". Questo ha risolto il problema!

\iffalse
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{immagine.png}
    \caption{Descrizione.}
\end{figure}
\fi

