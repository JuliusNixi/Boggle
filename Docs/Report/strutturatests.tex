\chapter{Struttura tests}

Inizialmente l'idea era di scrivere degli unit tests. Nello specifico cercare di rendere il progetto il pi\'u modulare possibile attraverso la scrittura di funzioni separate e testarne input ed output man a mano che si progrediva nello sviluppo. Ho intrapreso questa strada, testimone il fatto che nella cartella "./Tests/C/" ho lasciato il file "tests.c", il quale funziona, si pu\'o compilare ed eseguire. Tuttavia, con l'avanzare dello sviluppo, mi sono reso conto che per come ho strutturato il progetto era disastroso. Avrei potuto testare poche singole funzioni ma non ad un livello soddisfacente nell'insieme. Complice il fatto di avere i codici divisi in pi\'u file ed di aver utilizzato per molte funzionalit\'a variabili globali condivise. Allora, ho guardato qualche framework di testing in C, ma non ho trovato nulla che facesse al caso mio. Alla fine, ho pensato di fare i tests in modo esterno, pensando che forse questo approccio era proprio quello voluto per sondare altri argomenti trattati nel corso. Ho cos\'i creato un programma distinto che creasse tanti processi client, simulando proprio il comportamento di utenti ed interazioni con il server su larga scala. Ha funzionato benissimo! Ad ogni modo credo sia stato didatticamente utile perch\'e ho dovuto maneggiare descrittori, files, pipes e segnali. In questo modo ho potuto eseguire moltissimi tests che sono stati vitali e mi hanno permesso di correggere innumerevoli bugs che con pochi clients (testati manualmente) non si verificavano, soprattutto sviste con la memoria e la sincronizzazione. Per eseguire questi tests \'e sufficiente:

\begin{enumerate}
  \item Avviare il server con i parametri desiderati.
  \item Dalla root del progetto, dopo aver compilato con "make", eseguire "./paroliere\_tests server\_ip porta\_server". Oppure "make tests" per utilizzare IP e porta default.
\end{enumerate}
\leavevmode
Ci sono alcuni parametri all'inizio del file che possono essere modificati se voluto. Il file crea tantissimi processi client e per ognuno di essi svolge un numero di azioni che possono essere esattamente tutte quelle che un vero utente potrebbe eseguire. Inviare comandi non validi, registrarsi, richiedere la matrice, sottomettere una parola, di quelle valide e non valide, uscire e persino disconnettersi forzatamente. Tutto viene svolto casualmente con un intensivo uso di random (ma comunque replicabile tramite seed). Tra ogni azione si aspetta un numero casuale di millisecondi per aumentare l'entropia nelle sincronizzazioni. I comandi vengono sottomessi, creando il processo client con una chiamata "fork()", collegandosi tramite pipe al suo STDIN. L'input inviato (comandi spediti al server) e l'output ricevuto (le risposte che il client ha ricevuto dal server) vengono salvati in dei file di logs in "./Tests/C/Logs/" per potere esaminare che tutto funzioni correttamente.

