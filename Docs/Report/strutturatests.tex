\chapter{Struttura tests}

Inizialmente l'idea era di scrivere i tests in C in un file eseguibile separato. Ho intrapreso questa strada, testimone il fatto che nella cartella "./Tests/C/" ho lasciato il file "tests.c", il quale funziona, si pu\'o compilare ed eseguire. Tuttavia, con lo sviluppo mi sono reso conto che per come ho strutturato il progetto era disastroso. Avrei potuto testare poche singole funzioni ma non ad un livello soddisfacente nell'insieme. Causa il fatto di avere i codici divisi in pi\'u file ed di aver utilizzato per molte funzionalit\'a variabili globali condivise. Allora, ho guardato qualche framework di testing in C, ma non ho trovato nulla che facesse al caso mio. Cos\'i, messo alle strette, ho pensato di approcciare il problema in modo "particolare". Mi \'e venuto in mente che avrei potuto utilizzare la semplicit\'a e la potenza di Python, che conosco un poco, per fare i tests in modo esterno, ma simulando proprio il comportamento di utenti ed interazioni con il server anche su larga scala. Ha funzionato benissimo! Solamente \textbf{mi dispiace di esser dovuto andare a scomodare un linguaggio che esula dal corso}. Tuttavia, credo sia stato didatticamente utile perch\'e, seppur in un linguaggio diverso, ho dovuto maneggiare files, PIPES e segnali. In questo modo ho potuto eseguire moltissimi tests che sono stati vitali e mi hanno permesso di correggere innumerevoli bugs che con pochi clients (tstati manualmente) non si verificano, soprattutto sviste con la memoria. Per eseguire questi tests \'e sufficiente:

\begin{enumerate}
  \item Avviare il server con i parametri desiderati.
  \item Dalla root del progetto eseguire "python3 ./Tests/Python/pythontests.py server\_ip porta\_server". 
\end{enumerate}
\leavevmode
Ci sono alcuni parametri all'inizio del file che possono essere modificati se voluto. Il file crea tantissimi processi client e per ognuno di essi svolge un numero di azioni che possono essere esattamente tutte quelle che un vero utente potrebbe eseguire. Inviare comandi non validi, registrarsi, richiedere la matrice, sottomettere una parola, di quelle valide e non valide, uscire e persino disconnettersi forzatamente. Tutto viene svolto casualmente con un intensivo uso di random (ma comunque replicabile tramite seed). Tra ogni azione si aspetta un numero casuale di millisecondi per aumentare l'entropia. I comandi vengono sottomessi da Python, creando il processo del client  collegandosi tramite PIPE al suo STDIN. L'input inviato (comandi) e l'output ricevuto, ossia le risposte che il client ha ricevuto dal server, vengono salvati in dei file di logs in "./Tests/Python/Logs/".
\\
I tests dovrebbero funzionare con una recente (al 2024) versione di Python 3, con le librerie installate di default, senza richiedere alcuna risorsa esterna.
